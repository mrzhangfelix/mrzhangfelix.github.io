# 架构设计
## 请列举出在JDK中几个常用的设计模式？
单例模式（Singleton pattern）用于Runtime，Calendar和其他的一些类中。工厂模式（Factory pattern）被用于各种不可变的类如 Boolean，像Boolean.valueOf，观察者模式（Observer pattern）被用于 Swing 和很多的事件监听中。装饰器设计模式（Decorator design pattern）被用于多个 Java IO 类中。

##  设计模式原则 

- 单一职责原则

对类来说，即一个类应该只负责一项职责，如 A 类负责两个不同的职责：职责1、职责2,。当职责1 需求变更而改变 A 时，可能造成职责2 执行错误，所以需要将 A 类 的细粒度分解为 A1 和 A2

- 接口隔离原则

客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口

- 依赖倒置原则：

高层模块不应该依赖低层模块，二者应该依赖其抽象
抽象不应该依赖细节，细节应该依赖抽象
依赖倒置的中心思想是面向接口编程
依赖倒置原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在 Java 中，抽象指的是接口或抽象类，细节就是具体的实现类
使用接口或抽象类的目的就是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成

-  里氏替换原则 

 在使用继承时，遵循里氏替换原则，在子类中 **尽量** 不要重写父类的方法 

 里氏替换原则告诉我们，继承实际上是让两个类耦合性增强了，**在适当的情况下，可以通过聚合，组合，依赖来解决问题** 

 通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖，聚合，组合等关系代替 

-  开闭原则 

一个软件实体，如类、模块和函数应该对扩展开放（对提供方），对修改关闭（对使用方）。用抽象构建框架，用实现扩展细节

当软件需要变化时，尽量 **通过扩展** 软件实体的行为来实现变化，而 **不是通过修改** 已有的代码来实现变化

编程中遵循其它原则，以及使用设计模式的目的就是遵循 **开闭原则**

-  迪米特法则 

一个对象应该对其他对象保持最少的了解
类与类关系关系越密切，耦合度越大
迪米特法则又叫 最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的 public 方法，不对外泄露任何消息
迪米特法则还有个更简单的定义：只与直接的朋友通信
直接的朋友：每个对象都会与其他的对象有耦合关系，只要两个对象之间有耦合关系，我们就可以说这两个对象之间的朋友关系。耦合的方式有很多，依赖、关联、组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部

-  合成复用原则 

 尽量使用合成/聚合的方式，而不是使用继承 

找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起

针对接口编程，而不是针对实现编程

为了交互对象之间的 **松耦合设计** 而努力

## 什么是设计模式

   设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。设计模式是代码可用性的延伸

   设计模式分类：创建型模式，结构型模式，行为型模式
## 静态代理、JDK动态代理以及CGLIB动态代理
- 静态代理

静态代理其实就是在程序运行之前，提前写好被代理方法的代理类，编译后运行。

静态代理需要针对被代理的方法提前写好代理类，如果被代理的方法非常多则需要编写很多代码，因此，对于上述缺点，通过动态代理的方式进行了弥补。

- 动态代理

动态代理主要是通过反射机制，在运行时动态生成所需代理的class.

无论是动态代理还是静态带领，都需要定义接口，然后才能实现代理功能。这同样存在局限性，因此，为了解决这个问题，出现了第三种代理方式：cglib代理。

cglib代理
CGLib采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。
JDK动态代理与CGLib动态代理均是实现Spring AOP的基础。

代理对象的生成过程由Enhancer类实现，大概步骤如下：
1. 生成代理类Class的二进制字节码；
2. 通过Class.forName加载二进制字节码，生成Class对象；
3. 通过反射机制获取实例构造，并初始化代理类对象

 Spring 框架使用 Spring AOP 模块中的代理模式。在 Spring AOP 中，笔者可以创建对象的代理来实现横切关注点。 

## 单例模式
   程序中只有一个实例

单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

   意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。

   主要解决：一个全局使用的类频繁地创建与销毁。

   - 构造器私有化
   - 自行创建实例
   - 向外提供实例

   懒汉式，线程安全 延迟创建对象 
   1. 线程不安全，先判断有没有。
   2. 线程安全，使用synchronized锁定getInstance
   3. 静态内部类去创建

   饿汉式，线程安全  直接创建对象
   1. 直接实例化
   2. 枚举
   3. 静态代码快饿汉式（复杂实例化）

 Spring 框架提供了一个单例的 bean 来实现单例模式。 

## 工厂模式
   工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

   意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。

   主要解决：主要解决接口选择的问题。

类很复杂初始化由工厂来实现，简化代码量，减少繁琐的实例化过程

一个类有很多的子类可以使用工厂类来创建不同的子类

 Spring 框架使用工厂模式来实现 Spring 容器的 BeanFactory 和 ApplicationContext 接口。Spring 容器基于工厂模式为 Spring 应用程序创建 bean，并管理着每一个 bean 的生命周期。BeanFactory 和 ApplicationContext 是工厂接口，并且在 Spring 中存在有很多实现类。getBean() 方法是相对应的 bean 的工厂方法。 

## 观察者模式
   当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。

   意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

   主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。

 在 Spring 框架中，观察者模式用于实现 ApplicationContext 的事件处理功能。Spring 为我们提供了 ApplicationEvent 类和 ApplicationListener 接口来启用事件处理。Spring 应用程序中的任何 bean 实现 ApplicationListener 接口，都会接收到 ApplicationEvent 作为事件发布者推送的消息。在这里，事件发布者是主题(Subject) 和实现 ApplicationListener 的 bean 的观察者(Observer)。 



## 抽象工厂模式

 定义了一个接口用于创建相关或有依赖关系的对象簇，而无需明确指定具体类。 

在 Spring 框架中，FactoryBean 接口是基于抽象工厂模式设计的。Spring 提供了很多这个接口的实现，比如 ProxyFactoryBean、JndiFactoryBean、LocalSessionFactoryBean、LocalContainerEntityManagerFactoryBean 等。FactoryBean 帮助 Spring 构建它自己无法轻松构建的对象。通常这是用来构造具有许多依赖关系的复杂对象。它也可以根据配置构造高易变的逻辑。例如，在 Spring 框架中，LocalSessionFactoryBean 是 FactoryBean 的一个实现，它用于获取 Hibernate 配置的关联的 bean 的引用。这是一个数据源的特定配置，它在得到 SessionFactory 的对象之前被使用。对此，在一致的情况下可以用 LocalSessionFactoryBean 获取特定的数据源配置。读者可以将 FactoryBean 的 getObject() 方法的返回结果注入到任何其他属性中。



## 装饰器模式（Decorator Pattern）
   装饰器模式允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。

   意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。

   主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。



Spring 框架使用装饰器模式构建重要功能，如事务、缓存同步和与安全相关的任务。让我们看看一些 Spring 实现此模式的功能:

- 织入通知到 Spring 应用程序中。它使用装饰者模式的 CGLib 代理，其通过在运行时生成目标类的子类来工作。
- BeanDefinitionDecorator: 它通过使用自定义属性来增强 bean 的定义。
- WebSocketHandlerDecorator: 它用来增强一个 WebSocketHandler 附加行为。

## 适配器模式 （Adapter Pattern） 

作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。

　　　适配器模式通过定义一个新的接口（对要实现的功能加以抽象），和一个实现该接口的Adapter（适配器）类来透明地调用外部组件。这样替换外部组件时，最多只要修改几个Adapter类就可以了，其他源代码都不会受到影响。

　　　以手机为例子，每一种机型都自带有从电器，有一天自带充电器坏了，而且市场没有这类型充电器可买了，怎么办？万能充电器就可以解决，这个万能充电器就是适配器。

  　  适配器模式有两种形式，一种是类的适配，另一种自然就是对象的适配。

(1)类的适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。

​      (2)对象的适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个包装类，持有原类的一个实例，在包装类的方法中，调用实例的方法就行。



Spring 框架使用适配器模式来实现很多功能。以下列出的一些在 Spring 框架中使用到适配器模式的类:

- JpaVendorAdapter
- HibernateJpaVendorAdapter
- HandlerInterceptorAdapter
- MessageListenerAdapter
- SpringContextResourceAdapter
- ClassPreProcessorAgentAdapter
- RequestMappingHandlerAdapter
- AnnotationMethodHandlerAdapter
- WebMvcConfigurerAdapter

## 建造者模式

Spring 框架中有一些功能实现了建造者模式。以下是 Spring 框架中基于建造者模式的类:

- EmbeddedDatabaseBuilder
- AuthenticationManagerBuilder
- UriComponentsBuilder
- BeanDefinitionBuilder
- MockMvcWebClientBuilder

# 秒杀系统设计
## 什么是秒杀

   通俗一点讲就是网络商家为促销等目的组织的网上限时抢购活动

   业务特点
   - 高并发：秒杀的特点就是这样时间极短、 瞬间用户量大。
   - 库存量少：一般秒杀活动商品量很少，这就导致了只有极少量用户能成功购买到。
   - 业务简单：流程比较简单，一般都是下订单、扣库存、支付订单
   - 恶意请求，数据库压力大

   解决方案

   - 前端：页面资源静态化，按钮控制，使用答题校验码可以防止秒杀器的干扰，让更多用户有机会抢到
   - nginx：校验恶意请求，转发请求，负载均衡；动静分离，不走tomcat获取静态资源；gzip压缩，减少静态文件传输的体积，节省带宽，提高渲染速度   
   - 业务层：集群，多台机器处理，提高并发能力
   - redis：集群保证高可用，持久化数据；分布式锁（悲观锁）；缓存热点数据（库存）
   - mq：削峰限流，MQ堆积订单，保护订单处理层的负载，Consumer根据自己的消费能力来取Task，实际上下游的压力就可控了。重点做好路由层和MQ的安全
   - 数据库：读写分离，拆分事务提高并发度

   秒杀系统设计小结

   秒杀系统就是一个“三高”系统，即高并发、高性能和高可用的分布式系统
   秒杀设计原则：前台请求尽量少，后台数据尽量少，调用链路尽量短，尽量不要有单点
   秒杀高并发方法：访问拦截、分流、动静分离
   秒杀数据方法：减库存策略、热点、异步、限流降级
   访问拦截主要思路：通过CDN和缓存技术，尽量把访问拦截在离用户更近的层，尽可能地过滤掉无效请求。
   分流主要思路：通过分布式集群技术，多台机器处理，提高并发能力。

# 分布式系统设计理念
## 分布式系统的目标与要素
  分布式系统的目标是提升系统的整体性能和吞吐量另外还要尽量保证分布式系统的容错性（假如增加10台服务器才达到单机运行效果2倍左右的性能，那么这个分布式系统就根本没有存在的意义）。

  即使采用了分布式系统，我们也要尽力运用并发编程、高性能网络框架等等手段提升单机上的程序性能。

## 分布式系统设计两大思路：中心化和去中心化
**中心化设计**
- 两个角色： 中心化的设计思想很简单，分布式集群中的节点机器按照角色分工，大体上分为两种角色： “领导” 和 “干活的”
- 角色职责： “领导”通常负责分发任务并监督“干活的”，发现谁太闲了，就想发设法地给其安排新任务，确保没有一个“干活的”能够偷懒，如果“领导”发现某个“干活的”因为劳累过度而病倒了，则是不会考虑先尝试“医治”他的，而是一脚踢出去，然后把他的任务分给其他人。其中微服务架构 Kubernetes 就恰好采用了这一设计思路。
- 中心化设计的问题
    - 中心化的设计存在的最大问题是“领导”的安危问题，如果“领导”出了问题，则群龙无首，整个集群就奔溃了。但我们难以同时安排两个“领导”以避免单点问题。
    - 中心化设计还存在另外一个潜在的问题，既“领导”的能力问题：可以领导10个人高效工作并不意味着可以领导100个人高效工作，所以如果系统设计和实现得不好，问题就会卡在“领导”身上。
- 领导安危问题的解决办法： 大多数中心化系统都采用了主备两个“领导”的设计方案，可以是热备或者冷备，也可以是自动切换或者手动切换，而且越来越多的新系统都开始具备自动选举切换“领导”的能力，以提升系统的可用性。

**去中心化设计**
- 众生地位平等： 在去中心化的设计里，通常没有“领导”和“干活的”这两种角色的区分，大家的角色都是一样的，地位是平等的，全球互联网就是一个典型的去中心化的分布式系统，联网的任意节点设备宕机，都只会影响很小范围的功能。
- “去中心化”不是不要中心，而是由节点来自由选择中心。 （集群的成员会自发的举行“会议”选举新的“领导”主持工作。最典型的案例就是ZooKeeper及Go语言实现的Etcd）
- 去中心化设计的问题： 去中心化设计里最难解决的一个问题是 “脑裂”问题 ，这种情况的发生概率很低，但影响很大。脑裂指一个集群由于网络的故障，被分为至少两个彼此无法通信的单独集群，此时如果两个集群都各自工作，则可能会产生严重的数据冲突和错误。一般的设计思路是，当集群判断发生了脑裂问题时，规模较小的集群就“自杀”或者拒绝服务。

## 分布式与集群的区别是什么？
   - 分布式： 一个业务分拆多个子业务，部署在不同的服务器上
   - 集群： 同一个业务，部署在多个服务器上。比如之前做电商网站搭的redis集群以及solr集群都是属于将redis服务器提供的缓存服务以及solr服务器提供的搜索服务部署在多个服务器上以提高系统性能、并发量解决海量存储问题

## CAP定理

在理论计算机科学中，CAP定理（CAP theorem），又被称作布鲁尔定理（Brewer’s theorem），它指出对于一个分布式计算系统来说，不可能同时满足以下三点：

|选项	|描述|
|----|---|
|Consistency（一致性）|	指数据在多个副本之间能够保持一致的特性（严格的一致性）|
|Availability（可用性）|	指系统提供的服务必须一直处于可用的状态，每次请求都能获取到非错的响应（不保证获取的数据为最新数据）|
|Partition tolerance（分区容错性）	|分布式系统在遇到任何网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务，除非整个网络环境都发生了故障|

Spring Cloud在CAP法则上主要满足的是A和P法则，Dubbo和Zookeeper在CAP法则主要满足的是C和P法则

## BASE理论
   BASE理论由eBay架构师Dan Pritchett提出，在2008年上被分表为论文，并且eBay给出了他们在实践中总结的基于BASE理论的一套新的分布式事务解决方案。

   BASE 是 Basically Available（基本可用） 、Soft-state（软状态） 和 Eventually Consistent（最终一致性） 三个短语的缩写。BASE理论是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的，它大大降低了我们对系统的要求。

1. 基本可用
基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。

比如：
- 响应时间上的损失：正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障，查询结果的响应时间增加了1~2秒
- 系统功能上的损失：正常情况下，在一个电子商务网站上进行购物的时候，消费者几乎能够顺利完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面
2. 软状态
软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时

3. 最终一致性
最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。








