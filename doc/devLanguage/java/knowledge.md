# 常见知识点

## 面向对象(Object Oriented) 

面向对象是一种思想，是一种软件开发思想，将功能封装到对象之中，让对象实现功能细节；

### 特征有
抽象性；继承性；多态性；对象唯一性

 ### 继承的特性
 * 子类拥有父类非 private 的属性、方法。
 
 * 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。
 
 * 子类可以用自己的方式实现父类的方法。
 
 * Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C 类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。
 
 * 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。

### 多态的实现方式
- 方式一：重写
- 方式二：接口
- 方式三：抽象类和抽象方法

### Java 重写(Override)与重载(Overload)

重写(Override)
- 重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。
- 重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。
- 访问权限不能比父类中被重写的方法的访问权限更低。
- 声明为 final 的方法不能被重写。
- 声明为 static 的方法不能被重写，但是能够被再次声明。
- 构造方法不能被重写。
- 如果不能继承一个方法，则不能重写这个方法。

重载(Overload)
- 被重载的方法必须改变参数列表(参数个数或类型不一样)；
- 被重载的方法可以改变返回类型；
- 被重载的方法可以改变访问修饰符；
- 被重载的方法可以声明新的或更广的检查异常；
- 方法能够在同一个类中或者在一个子类中被重载。
- 无法以返回值类型作为重载函数的区分标准。

### 抽象类
1. 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。

2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。

3. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。

4. 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。

5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。

### 接口
1. 接口不能用于实例化对象。
1. 接口没有构造方法。
1. 接口中所有的方法必须是抽象方法。接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。
1. 接口不能包含成员变量，除了 static 和 final 变量。
1. 接口不是被类继承了，而是要被类实现。
1. 接口支持多继承。
1. 接口中的方法都是公有的。


## 修饰符

| 修饰符    | 当前类 | 同 包 | 子 类 | 其他包 |
| --------- | ------ | ----- | ----- | ------ |
| public    | Y      | Y     | Y     | Y      |
| protected | Y      | Y     | Y     | N      |
| default   | Y      | Y     | N     | N      |
| private   | Y      | N     | N     | N      |


- static 修饰符，用来修饰类方法和类变量。对类变量和方法的访问可以直接使用 **classname.variablename** 和 **classname.methodname** 的方式访问。 
静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，在调用静态方法时可能对象并没有被初始化。
静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。

- final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。

- abstract 修饰符，用来创建抽象类和抽象方法。抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。 抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。 

- synchronized 和 volatile 修饰符，主要用于线程的编程。synchronized 关键字声明的方法同一时间只能被一个线程访问 ，volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。 

## 变量
- **局部变量**：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。
- **成员变量**：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。
- **类变量**：类变量也声明在类中，方法体之外，但必须声明为static类型


## 基本数据类型

* byte：占用1个字节（8位），范围：-2^7~2^7-1 Byte 
* short：占用2个字节（16位)，范围：-2^15~2^15-1 Short 
* int：占用4个字节（32位），范围：-2^31~2^31-1 Integer 
* long：占用8个字节（64位），范围：-2^63~2^63-1 Long 
* float：占用4个字节（32位，1位符号位，8位指数位），范围：2^-149~2^128-1 Float 
* double：占用8个字节（64位，1位符号位，11位指数位），范围2^-1074~2^1024-1 Double 
* char：单一的 16 位 Unicode 字符； 两个字节 Character 
* boolean  boolean数据类型表示一位的信息；只有两个取值：true 和 false；Boolean 

## 环境变量

- 变量名：**JAVA_HOME**
- 变量值：**C:\Program Files (x86)\Java\jdk1.8.0_91**        // 要根据自己的实际路径配置

- 变量名：**CLASSPATH**
- 变量值：**.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;**         //记得前面有个"."

- 变量名：**Path**

- 变量值：**%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;**

  ## 转义字符

  | 字符 | 含义         |
  | ---- | ------------ |
  | \n   | 换行 (0x0a)  |
  | \r   | 回车 (0x0d)  |
  | \f   | 换页符(0x0c) |
  | \b   | 退格 (0x08)  |
  | \0   | 空字符 (0x0) |
  | \s   | 空格 (0x20)  |
  | \t   | 制表符       |

## StringBuilder和StringBuffer
StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。 
StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。

## 正则表达式
正则表达式定义了字符串的模式。正则表达式可以用来搜索、编辑或处理文本
捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。
Pattern 类：
pattern 对象是一个正则表达式的编译表示。
Matcher 类：
Matcher 对象是对输入字符串进行解释和匹配操作的引擎。
PatternSyntaxException：
PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。

| 字符          | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| \             | 将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，"n"匹配字符"n"。"\n"匹配换行符。序列"\\\\"匹配"\\"，"\\("匹配"("。 |
| ^             | 匹配输入字符串开始的位置。如果设置了 **RegExp** 对象的 **Multiline** 属性，^ 还会与"\n"或"\r"之后的位置匹配。 |
| $             | 匹配输入字符串结尾的位置。如果设置了 **RegExp** 对象的 **Multiline** 属性，$ 还会与"\n"或"\r"之前的位置匹配。 |
| *             | 零次或多次匹配前面的字符或子表达式。例如，zo* 匹配"z"和"zoo"。* 等效于 {0,}。 |
| +             | 一次或多次匹配前面的字符或子表达式。例如，"zo+"与"zo"和"zoo"匹配，但与"z"不匹配。+ 等效于 {1,}。 |
| ?             | 零次或一次匹配前面的字符或子表达式。例如，"do(es)?"匹配"do"或"does"中的"do"。? 等效于 {0,1}。 |
| {*n*}         | *n* 是非负整数。正好匹配 *n* 次。例如，"o{2}"与"Bob"中的"o"不匹配，但与"food"中的两个"o"匹配。 |
| {*n*,}        | *n* 是非负整数。至少匹配 *n* 次。例如，"o{2,}"不匹配"Bob"中的"o"，而匹配"foooood"中的所有 o。"o{1,}"等效于"o+"。"o{0,}"等效于"o*"。 |
| {*n*,*m*}     | *m* 和 *n* 是非负整数，其中 *n* <= *m*。匹配至少 *n* 次，至多 *m* 次。例如，"o{1,3}"匹配"fooooood"中的头三个 o。'o{0,1}' 等效于 'o?'。注意：您不能将空格插入逗号和数字之间。 |
| ?             | 当此字符紧随任何其他限定符（*、+、?、{*n*}、{*n*,}、{*n*,*m*}）之后时，匹配模式是"非贪心的"。"非贪心的"模式匹配搜索到的、尽可能短的字符串，而默认的"贪心的"模式匹配搜索到的、尽可能长的字符串。例如，在字符串"oooo"中，"o+?"只匹配单个"o"，而"o+"匹配所有"o"。 |
| .             | 匹配除"\r\n"之外的任何单个字符。若要匹配包括"\r\n"在内的任意字符，请使用诸如"[\s\S]"之类的模式。 |
| (*pattern*)   | 匹配 *pattern* 并捕获该匹配的子表达式。可以使用 **$0…$9** 属性从结果"匹配"集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用"\("或者"\)"。 |
| (?:*pattern*) | 匹配 *pattern* 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用"or"字符 (\|) 组合模式部件的情况很有用。例如，'industr(?:y\|ies) 是比 'industry\|industries' 更经济的表达式。 |
| (?=*pattern*) | 执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 *pattern* 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，'Windows (?=95\|98\|NT\|2000)' 匹配"Windows 2000"中的"Windows"，但不匹配"Windows 3.1"中的"Windows"。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。 |
| (?!*pattern*) | 执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 *pattern* 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，'Windows (?!95\|98\|NT\|2000)' 匹配"Windows 3.1"中的 "Windows"，但不匹配"Windows 2000"中的"Windows"。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。 |
| *x*\|*y*      | 匹配 *x* 或 *y*。例如，'z\|food' 匹配"z"或"food"。'(z\|f)ood' 匹配"zood"或"food"。 |
| [*xyz*]       | 字符集。匹配包含的任一字符。例如，"[abc]"匹配"plain"中的"a"。 |
| [^*xyz*]      | 反向字符集。匹配未包含的任何字符。例如，"[^abc]"匹配"plain"中"p"，"l"，"i"，"n"。 |
| [*a-z*]       | 字符范围。匹配指定范围内的任何字符。例如，"[a-z]"匹配"a"到"z"范围内的任何小写字母。 |
| [^*a-z*]      | 反向范围字符。匹配不在指定的范围内的任何字符。例如，"[^a-z]"匹配任何不在"a"到"z"范围内的任何字符。 |
| \b            | 匹配一个字边界，即字与空格间的位置。例如，"er\b"匹配"never"中的"er"，但不匹配"verb"中的"er"。 |
| \B            | 非字边界匹配。"er\B"匹配"verb"中的"er"，但不匹配"never"中的"er"。 |
| \c*x*         | 匹配 *x* 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。*x* 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是"c"字符本身。 |
| \d            | 数字字符匹配。等效于 [0-9]。                                 |
| \D            | 非数字字符匹配。等效于 [^0-9]。                              |
| \f            | 换页符匹配。等效于 \x0c 和 \cL。                             |
| \n            | 换行符匹配。等效于 \x0a 和 \cJ。                             |
| \r            | 匹配一个回车符。等效于 \x0d 和 \cM。                         |
| \s            | 匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。 |
| \S            | 匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效。                 |
| \t            | 制表符匹配。与 \x09 和 \cI 等效。                            |
| \v            | 垂直制表符匹配。与 \x0b 和 \cK 等效。                        |
| \w            | 匹配任何字类字符，包括下划线。与"[A-Za-z0-9_]"等效。         |
| \W            | 与任何非单词字符匹配。与"[^A-Za-z0-9_]"等效。                |
| \x*n*         | 匹配 *n*，此处的 *n* 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，"\x41"匹配"A"。"\x041"与"\x04"&"1"等效。允许在正则表达式中使用 ASCII 代码。 |
| \*num*        | 匹配 *num*，此处的 *num* 是一个正整数。到捕获匹配的反向引用。例如，"(.)\1"匹配两个连续的相同字符。 |
| \*n*          | 标识一个八进制转义码或反向引用。如果 \*n* 前面至少有 *n* 个捕获子表达式，那么 *n* 是反向引用。否则，如果 *n* 是八进制数 (0-7)，那么 *n* 是八进制转义码。 |
| \*nm*         | 标识一个八进制转义码或反向引用。如果 \*nm* 前面至少有 *nm* 个捕获子表达式，那么 *nm* 是反向引用。如果 \*nm* 前面至少有 *n* 个捕获，则 *n* 是反向引用，后面跟有字符 *m*。如果两种前面的情况都不存在，则 \*nm* 匹配八进制值 *nm*，其中 *n* 和 *m* 是八进制数字 (0-7)。 |
| \nml          | 当 *n* 是八进制数 (0-3)，*m* 和 *l* 是八进制数 (0-7) 时，匹配八进制转义码 *nml*。 |
| \u*n*         | 匹配 *n*，其中 *n* 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。 |

## 异常
检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。

运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。

错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。
常见的检查性异常

检查性异常

| 异常                          | 描述 |
| -------------------------     | ----------- |
|  ClassNotFoundException       |	应用程序试图加载类时，找不到相应的类，抛出该异常。 |
|  CloneNotSupportedException   |	当调用 Object 类中的 clone 方法克隆对象，但该对象的类无法实现 Cloneable 接口时，抛出该异常。|
|  IllegalAccessException       |	拒绝访问一个类的时候，抛出该异常。 |
|  InstantiationException       |	当试图使用 Class 类中的 newInstance 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。|
|  InterruptedException         |	一个线程被另一个线程中断，抛出该异常。 |
|  NoSuchFieldException         |	请求的变量不存在 |
|  NoSuchMethodException        |	请求的方法不存在 |

运行时异常

| 异常                                |	描述              |
|---                                |---                |
| ArithmeticException               |	当出现异常的运算条件时，抛出此异常。例如，一个整数"除以零"时，抛出此类的一个实例。 |
| ArrayIndexOutOfBoundsException    |	用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。 |
| ArrayStoreException               |	试图将错误类型的对象存储到一个对象数组时抛出的异常。 |
| ClassCastException                |	当试图将对象强制转换为不是实例的子类时，抛出该异常。 |
| IllegalArgumentException          |	抛出的异常表明向方法传递了一个不合法或不正确的参数。 |
| IllegalMonitorStateException      |	抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。 |
| IllegalStateException             |	在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。 |
| IllegalThreadStateException       |	线程没有处于请求操作所要求的适当状态时抛出的异常。 |
| IndexOutOfBoundsException	        |   指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。 |
| NegativeArraySizeException        |	如果应用程序试图创建大小为负的数组，则抛出该异常。 |
| NullPointerException              |	当应用程序试图在需要对象的地方使用 null 时，抛出该异常 |
| NumberFormatException             |	当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。 |
| SecurityException	                |   由安全管理器抛出的异常，指示存在安全侵犯。 |
| StringIndexOutOfBoundsException   |	此异常由 String 方法抛出，指示索引或者为负，或者超出字符串的大小。 |
| UnsupportedOperationException     |	当不支持请求的操作时，抛出该异常。 |

## 集合框架
LinkedList 该类实现了List接口，允许有null（空）元素。主要用于创建链表数据结构，LinkedList 查找效率低。

ArrayList 实现了List的接口，实现了可变大小的数组，随机访问和遍历元素时，提供更好的性能。是非同步的,多线程不要使用。ArrayList增长当前长度的50%，插入删除效率低。

HashSet 该类实现了Set接口，不允许出现重复元素，不保证集合中元素的顺序，允许包含值为null的元素，但最多只能一个。

TreeSet 该类实现了Set接口，可以实现排序等功能。

HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。实现了Map接口，键的HashCode值存储数据，具有很快的访问速度，最多允许一条记录的键为null，不支持线程同步。

TreeMap 继承了AbstractMap，并且使用一颗树。

## 多线程
创建线程的方法：

- 通过实现 Runnable 接口；
- 通过继承 Thread 类本身；
- 通过 Callable 和 Future 创建线程。


























