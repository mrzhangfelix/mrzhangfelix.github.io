# 常见知识点

## 面向对象(Object Oriented) 

面向对象是一种思想，是一种软件开发思想，将功能封装到对象之中，让对象实现功能细节；

### 特征
抽象性；继承性；多态性；对象唯一性

 ### 继承的特性
 * 子类拥有父类非 private 的属性、方法。

 * 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。

 * 子类可以用自己的方式实现父类的方法。

 * Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C 类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。

 * 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。

### 多态的实现方式
- 方式一：重写
- 方式二：接口
- 方式三：抽象类和抽象方法

### Java 重写(Override)与重载(Overload)

重写(Override)
- 重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。
- 重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。
- 访问权限不能比父类中被重写的方法的访问权限更低。
- 声明为 final 的方法不能被重写。
- 声明为 static 的方法不能被重写，但是能够被再次声明。
- 构造方法不能被重写。
- 如果不能继承一个方法，则不能重写这个方法。

重载(Overload)
- 被重载的方法必须改变参数列表(参数个数或类型不一样)；
- 被重载的方法可以改变返回类型；
- 被重载的方法可以改变访问修饰符；
- 被重载的方法可以声明新的或更广的检查异常；
- 方法能够在同一个类中或者在一个子类中被重载。
- 无法以返回值类型作为重载函数的区分标准。

注意成员变量不具有多态性，因此你定义的是A，赋值的是B， 那么输出的依旧是A里的成员。
如果是被重写的方法的话，那会用B里的方法。

 

### 抽象类
1. 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。

2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。

3. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。

4. 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。

5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。

### 接口
1. 接口不能用于实例化对象。

1. 接口没有构造方法。

1. 接口中所有的方法必须是抽象方法。接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。

1. 接口不能包含成员变量，除了 static 和 final 变量。

1. 接口不是被类继承了，而是要被类实现。

1. 接口支持多继承。

1. 接口中的方法都是公有的。

   


## 修饰符

| 修饰符    | 当前类 | 同 包 | 子 类 | 其他包 |
| --------- | ------ | ----- | ----- | ------ |
| public    | Y      | Y     | Y     | Y      |
| protected | Y      | Y     | Y     | N      |
| default   | Y      | Y     | N     | N      |
| private   | Y      | N     | N     | N      |


- static 修饰符，用来修饰类方法和类变量。对类变量和方法的访问可以直接使用 **classname.variablename** 和 **classname.methodname** 的方式访问。 
静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，在调用静态方法时可能对象并没有被初始化。
静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。
- final 修饰符，用来修饰类、方法和变量，

  - final 修饰的类不能够被继承，
  - 修饰的方法不能被继承类重新定义，
  - 修饰的变量为常量，是不可修改的。
  - 当用final关键字修饰方法后，该方法在子类中将无法重写，只能继承。
- abstract 修饰符，用来创建抽象类和抽象方法。抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。 抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。 
- synchronized 和 volatile 修饰符，主要用于线程的编程。synchronized 关键字声明的方法同一时间只能被一个线程访问 ，volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。 

## 变量
- **局部变量**：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。
- **成员变量**：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。
- **类变量**：类变量也声明在类中，方法体之外，但必须声明为static类型


## 基本数据类型

* byte：占用1个字节（8位），范围：-2^7~2^7-1 Byte 
* short：占用2个字节（16位)，范围：-2^15~2^15-1 Short 
* int：占用4个字节（32位），范围：-2^31~2^31-1 Integer 
* long：占用8个字节（64位），范围：-2^63~2^63-1 Long 
* float：占用4个字节（32位，1位符号位，8位指数位），范围：2^-149~2^128-1 Float 
* double：占用8个字节（64位，1位符号位，11位指数位），范围2^-1074~2^1024-1 Double 
* char：单一的 16 位 Unicode 字符； 两个字节 Character 
* boolean  bool类型无空间大小，boolean数据类型表示一位的信息；只有两个取值：true 和 false；Boolean 

 short、int、long、float、double、byte、char、boolean的 包装类型， 以及String，这9种属于不可变类型。（这只是部分，还有其他的不可变类）

不可变类型概念：里面的值的内容变了，对应的内存地址也会变化。

 类里的成员如果是基本数据类型初始化为0或者false。

 java中局部变量没初始化，会报错

 布尔类型不可以强制转化成其他类型

 byte/short/char)<int<long<float<double
 即隐式转换都是从低往高转。

 2个byte类型变量相加的时候，会自动转换成int类型，右边的int类型赋值给short类型

值的范围在-128~127的时候Integer可以直接用==比较大小，但是超出这个范围时，==就不管用了，要用equals

浮点数相等的比较方式 if(Math.abs(a-b))<1E-6F)



## 流程控制语句

```java
int i = 0;
switch (i) {
  default:
    System.out.println("default");
  case 0:
    System.out.println("0");
  case 1:
    System.out.println("1");
}
```

输出"0,1"

```java
int i = 3;
switch (i) {
  default:
    System.out.println("default");
  case 0:
    System.out.println("0");
  case 1:
    System.out.println("1");
}
```

 输出"default 0 1"， 

```java
int f() {
  int a = 1;
  try {
      return a;
  }
  finally {
      a=2;
  }
}
```

返回1

```java
int f() {
  try {
      return 1;
  }
  finally {
      return 2;
  }
}
```

返回2

Swith支持的类型：byte、short、char、int、enum、String


## 环境变量

- 变量名：**JAVA_HOME**
- 变量值：**C:\Program Files (x86)\Java\jdk1.8.0_91**        // 要根据自己的实际路径配置

- 变量名：**CLASSPATH**
- 变量值：**.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;**         //记得前面有个"."

- 变量名：**Path**

- 变量值：**%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;**

  ## 转义字符

  | 字符 | 含义         |
  | ---- | ------------ |
  | \n   | 换行 (0x0a)  |
  | \r   | 回车 (0x0d)  |
  | \f   | 换页符(0x0c) |
  | \b   | 退格 (0x08)  |
  | \0   | 空字符 (0x0) |
  | \s   | 空格 (0x20)  |
  | \t   | 制表符       |

## 字符串
StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。 
StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。

HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快



## 正则表达式
正则表达式定义了字符串的模式。正则表达式可以用来搜索、编辑或处理文本
捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。
Pattern 类：
pattern 对象是一个正则表达式的编译表示。
Matcher 类：
Matcher 对象是对输入字符串进行解释和匹配操作的引擎。
PatternSyntaxException：
PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。

| 字符          | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| \             | 将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，"n"匹配字符"n"。"\n"匹配换行符。序列"\\\\"匹配"\\"，"\\("匹配"("。 |
| ^             | 匹配输入字符串开始的位置。如果设置了 **RegExp** 对象的 **Multiline** 属性，^ 还会与"\n"或"\r"之后的位置匹配。 |
| $             | 匹配输入字符串结尾的位置。如果设置了 **RegExp** 对象的 **Multiline** 属性，$ 还会与"\n"或"\r"之前的位置匹配。 |
| *             | 零次或多次匹配前面的字符或子表达式。例如，zo* 匹配"z"和"zoo"。* 等效于 {0,}。 |
| +             | 一次或多次匹配前面的字符或子表达式。例如，"zo+"与"zo"和"zoo"匹配，但与"z"不匹配。+ 等效于 {1,}。 |
| ?             | 零次或一次匹配前面的字符或子表达式。例如，"do(es)?"匹配"do"或"does"中的"do"。? 等效于 {0,1}。 |
| {*n*}         | *n* 是非负整数。正好匹配 *n* 次。例如，"o{2}"与"Bob"中的"o"不匹配，但与"food"中的两个"o"匹配。 |
| {*n*,}        | *n* 是非负整数。至少匹配 *n* 次。例如，"o{2,}"不匹配"Bob"中的"o"，而匹配"foooood"中的所有 o。"o{1,}"等效于"o+"。"o{0,}"等效于"o*"。 |
| {*n*,*m*}     | *m* 和 *n* 是非负整数，其中 *n* <= *m*。匹配至少 *n* 次，至多 *m* 次。例如，"o{1,3}"匹配"fooooood"中的头三个 o。'o{0,1}' 等效于 'o?'。注意：您不能将空格插入逗号和数字之间。 |
| ?             | 当此字符紧随任何其他限定符（*、+、?、{*n*}、{*n*,}、{*n*,*m*}）之后时，匹配模式是"非贪心的"。"非贪心的"模式匹配搜索到的、尽可能短的字符串，而默认的"贪心的"模式匹配搜索到的、尽可能长的字符串。例如，在字符串"oooo"中，"o+?"只匹配单个"o"，而"o+"匹配所有"o"。 |
| .             | 匹配除"\r\n"之外的任何单个字符。若要匹配包括"\r\n"在内的任意字符，请使用诸如"[\s\S]"之类的模式。 |
| (*pattern*)   | 匹配 *pattern* 并捕获该匹配的子表达式。可以使用 **$0…$9** 属性从结果"匹配"集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用"\("或者"\)"。 |
| (?:*pattern*) | 匹配 *pattern* 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用"or"字符 (\|) 组合模式部件的情况很有用。例如，'industr(?:y\|ies) 是比 'industry\|industries' 更经济的表达式。 |
| (?=*pattern*) | 执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 *pattern* 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，'Windows (?=95\|98\|NT\|2000)' 匹配"Windows 2000"中的"Windows"，但不匹配"Windows 3.1"中的"Windows"。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。 |
| (?!*pattern*) | 执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 *pattern* 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，'Windows (?!95\|98\|NT\|2000)' 匹配"Windows 3.1"中的 "Windows"，但不匹配"Windows 2000"中的"Windows"。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。 |
| *x*\|*y*      | 匹配 *x* 或 *y*。例如，'z\|food' 匹配"z"或"food"。'(z\|f)ood' 匹配"zood"或"food"。 |
| [*xyz*]       | 字符集。匹配包含的任一字符。例如，"[abc]"匹配"plain"中的"a"。 |
| [^*xyz*]      | 反向字符集。匹配未包含的任何字符。例如，"[^abc]"匹配"plain"中"p"，"l"，"i"，"n"。 |
| [*a-z*]       | 字符范围。匹配指定范围内的任何字符。例如，"[a-z]"匹配"a"到"z"范围内的任何小写字母。 |
| [^*a-z*]      | 反向范围字符。匹配不在指定的范围内的任何字符。例如，"[^a-z]"匹配任何不在"a"到"z"范围内的任何字符。 |
| \b            | 匹配一个字边界，即字与空格间的位置。例如，"er\b"匹配"never"中的"er"，但不匹配"verb"中的"er"。 |
| \B            | 非字边界匹配。"er\B"匹配"verb"中的"er"，但不匹配"never"中的"er"。 |
| \c*x*         | 匹配 *x* 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。*x* 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是"c"字符本身。 |
| \d            | 数字字符匹配。等效于 [0-9]。                                 |
| \D            | 非数字字符匹配。等效于 [^0-9]。                              |
| \f            | 换页符匹配。等效于 \x0c 和 \cL。                             |
| \n            | 换行符匹配。等效于 \x0a 和 \cJ。                             |
| \r            | 匹配一个回车符。等效于 \x0d 和 \cM。                         |
| \s            | 匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。 |
| \S            | 匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效。                 |
| \t            | 制表符匹配。与 \x09 和 \cI 等效。                            |
| \v            | 垂直制表符匹配。与 \x0b 和 \cK 等效。                        |
| \w            | 匹配任何字类字符，包括下划线。与"[A-Za-z0-9_]"等效。         |
| \W            | 与任何非单词字符匹配。与"[^A-Za-z0-9_]"等效。                |
| \x*n*         | 匹配 *n*，此处的 *n* 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，"\x41"匹配"A"。"\x041"与"\x04"&"1"等效。允许在正则表达式中使用 ASCII 代码。 |
| \*num*        | 匹配 *num*，此处的 *num* 是一个正整数。到捕获匹配的反向引用。例如，"(.)\1"匹配两个连续的相同字符。 |
| \*n*          | 标识一个八进制转义码或反向引用。如果 \*n* 前面至少有 *n* 个捕获子表达式，那么 *n* 是反向引用。否则，如果 *n* 是八进制数 (0-7)，那么 *n* 是八进制转义码。 |
| \*nm*         | 标识一个八进制转义码或反向引用。如果 \*nm* 前面至少有 *nm* 个捕获子表达式，那么 *nm* 是反向引用。如果 \*nm* 前面至少有 *n* 个捕获，则 *n* 是反向引用，后面跟有字符 *m*。如果两种前面的情况都不存在，则 \*nm* 匹配八进制值 *nm*，其中 *n* 和 *m* 是八进制数字 (0-7)。 |
| \nml          | 当 *n* 是八进制数 (0-3)，*m* 和 *l* 是八进制数 (0-7) 时，匹配八进制转义码 *nml*。 |
| \u*n*         | 匹配 *n*，其中 *n* 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。 |





## IO



- InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
- OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。

File对象本身可以是目录。
调用file.mkdirs()即可创建目录。

如果是文件或者空目录，可以直接删除。
但如果目录中有文件或者子目录，则必须递归删除。

- 字节数组char[] 作为输入源的InputStream类是————ByteArrayInputStream
- 用文件作为输入源的InputStream类是？————FileInputStream
- 用字符串作为输入源的是？————StringBufferInputStream
- 用于多线程之间管道通信的输入源是————PipeInputStream

BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。
NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。
AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。


## 判断相等

hashCode()与equals()的相关规定

如果两个对象相等，则hashcode一定也是相同的

两个对象相等，对两个对象分别调用equals方法都返回true

两个对象有相同的hashcode值，它们也不一定是相等的

因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖

hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）

## 值传递



当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递
是值传递。Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的

为什么 Java 中只有值传递
首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。 它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。

Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。

## 反射



JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。

静态编译和动态编译

**静态编译：**在编译时确定类型，绑定对象
**动态编译：**运行时确定类型，绑定对象

### 反射机制优缺点

- **优点：** 运行期类型的判断，动态加载类，提高代码灵活度。
- **缺点：** 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。



反射是框架设计的灵魂。

在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。

1.通过new对象实现反射机制 2.通过路径实现反射机制 3.通过类名实现反射机制



